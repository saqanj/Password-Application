import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Set;

/**
 * A random password is generated by selecting a custom number of english
 * letters, numbers, and special characters desired by the user in their
 * password.
 * 
 * Regardless of how many characters from each category the user desires, each
 * possible character from each category is assigned a random and fair
 * probability value between 0 and 1, exclusive. Then, based on how many
 * characters from each category the user selected, the program selects N
 * characters with the highest probabilities from each category, where N denotes
 * the amount desired by the user. The probabilities are sorted from highest to
 * lowest using a modification of quick-sort and the finalized password is
 * shuffled using the Fisher-Yates algorithm for shuffling Strings.
 * 
 * @author Saqlain Anjum
 * @version 1.0.0
 * @since 01/02/2024
 */
public class MyPasswordGenerator extends SimplePasswordGenerator {

    /**
     * Used to generate random probabilities for the given Valid Character Arrays in
     * the super-class.
     * 
     * @param chosenArray a chosen array from the ones defined in this class.
     * @return A HashMap of characters as keys and random probabilities as values.
     */
    @Override
    protected HashMap<Character, Double> generateProbabilities(Character[] chosenArray) {
        HashMap<Character, Double> probabilities = new HashMap<Character, Double>();
        for (int i = 0; i < chosenArray.length; i++) {
            probabilities.put(chosenArray[i], Math.random());
        }
        return probabilities;
    }

    /**
     * Chooses the characters with the highest probabilities and returns them as an
     * ArrayList.
     * 
     * @param numChars      desired number of characters.
     * @param probabilities HashMap of character-probability pairs.
     * @return an ArrayList of chosen characters sorted in order of the highest
     *         probabilities to least.
     */
    private ArrayList<Character> chooseAndSortCharacters(int numChars, HashMap<Character, Double> probabilities) {
        ArrayList<Character> chosenAndSortedCharacters = new ArrayList<Character>(numChars);
        Set<Map.Entry<Character, Double>> probabilityEntrySet = probabilities.entrySet();
        ArrayList<Map.Entry<Character, Double>> probabilityEntryList = new ArrayList<Map.Entry<Character, Double>>();
        int index = 0;
        int index2 = 0;
        for (Map.Entry<Character, Double> entry : probabilityEntrySet) {
            probabilityEntryList.add(index, entry);
            index++;
        } // converting set to arraylist so quicksort can be supported.
        quickSort(probabilityEntryList, 0, probabilityEntryList.size() - 1);
        Iterator<Map.Entry<Character, Double>> entryIterator = probabilityEntryList.iterator();
        while (index2 < numChars) {
            if (entryIterator.hasNext()) {
                chosenAndSortedCharacters.add(index2, entryIterator.next().getKey());
                index2++;
            }
        }
        return chosenAndSortedCharacters;
    }

    /**
     * A quick-sort algorithm for the character-probability HashMap entries, sorting
     * from highest-lowest based off of probability values in the HashMap.
     * 
     * @param arrayList an ArrayList of HashMap entries.
     * @param start     the starting index of the ArrayList.
     * @param end       the ending index of the ArrayList.
     */
    private void quickSort(ArrayList<Map.Entry<Character, Double>> arrayList, int start, int end) {
        if (start < end) {
            int partitionIndex = partition(arrayList, start, end);
            quickSort(arrayList, start, partitionIndex - 1);
            quickSort(arrayList, partitionIndex + 1, end);
        }
    }

    /**
     * Determines the partition index of the ArrayList in the quick-sort algorithm.
     * 
     * @param arrayList the provided ArrayList that is being sorted.
     * @param start     the start index.
     * @param end       the ending index.
     * @return the partition index of the ArrayList.
     */
    private int partition(ArrayList<Map.Entry<Character, Double>> arrayList, int start, int end) {
        double pivot = arrayList.get(end).getValue();
        int s = start - 1;
        for (int e = start; e < end; e++) {
            if (arrayList.get(e).getValue() > pivot) { // sort from greatest to least.
                s++;
                entryListSwap(arrayList, s, e);
            }
        }
        entryListSwap(arrayList, s + 1, end);
        return s + 1;
    }

    /**
     * Swapping values of an ArrayList of HashMap entries.
     * 
     * @param entryList the provided ArrayList of HashMap entries.
     * @param s         the first index needing to be swapped.
     * @param e         the second index needing to be swapped.
     */
    private void entryListSwap(ArrayList<Map.Entry<Character, Double>> arrayList, int s, int e) {
        Map.Entry<Character, Double> temp = arrayList.get(s);
        arrayList.set(s, arrayList.get(e));
        arrayList.set(e, temp);
    }

    /**
     * Builds the final shuffled password from the ArrayLists of random letters,
     * numbers, and special characters that have been generated.
     * 
     * @param randomLetters           ArrayList of random letters generated by the
     *                                user.
     * @param randomNumbers           ArrayList of random numbers generated by the
     *                                user.
     * @param randomSpecialCharacters ArrayList of random special characters
     *                                generated by the user.
     * @return the finalized shuffled password as a String.
     */
    private String passwordBuilder(ArrayList<Character> randomLetters, ArrayList<Character> randomNumbers,
            ArrayList<Character> randomSpecialCharacters) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < randomLetters.size(); i++) {
            builder.append(randomLetters.get(i));
        }
        for (int i = 0; i < randomNumbers.size(); i++) {
            builder.append(randomNumbers.get(i));
        }
        for (int i = 0; i < randomSpecialCharacters.size(); i++) {
            builder.append(randomSpecialCharacters.get(i));
        }
        String unshuffledPassword = builder.toString();
        String shuffledPassword = fisherYatesShuffle(unshuffledPassword);
        return shuffledPassword;
    }

    /**
     * An implementation of the Fisher-Yates shuffling algorithm using Java's random
     * library for providing random permutations. Used to shuffle the assembled
     * password for finalization.
     * 
     * @param assembledPassword the assembeled password.
     * @return the shuffled password as a String.
     */
    private String fisherYatesShuffle(String assembledPassword) {
        char[] charArray = assembledPassword.toCharArray();
        Random randomizer = new Random();
        for (int index = 0; index < charArray.length; index++) {
            int randomIndex = randomizer.nextInt(index + 1);
            charArraySwap(charArray, index, randomIndex);
        }
        return new String(charArray);
    }

    /**
     * A swapping method for 2 elements of a given character array.
     * 
     * @param array  the provided array.
     * @param index1 first index to swap.
     * @param index2 second index to swap.
     */
    private void charArraySwap(char[] array, int index1, int index2) {
        char temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
    }

    /**
     * Used to generate an ArrayList of random letters given the number of random
     * letters desired in the final password.
     * 
     * @param size the number of random letters desired in the final password.
     * @return an ArrayList of random letters as characters.
     * @throws IllegalArgumentException if desired size of characters is larger than
     *                                  the ones available in the Array.
     */
    @Override
    protected ArrayList<Character> generateRandomLetters(int size) throws IllegalArgumentException {
        if (size > VALID_ENGLISH_LETTERS.length) {
            throw new IllegalArgumentException("This password size is not supported yet :(. Sorry.");
        }
        HashMap<Character, Double> probabilityMap = generateProbabilities(VALID_ENGLISH_LETTERS);
        return chooseAndSortCharacters(size, probabilityMap);
    }

    /**
     * Used to generate an ArrayList of random numbers given the amount of random
     * numbers desired in the final password.
     * 
     * @param size the number of random numbers desired in the final password.
     * @return an ArrayList of random numbers as characters.
     * @throws IllegalArgumentException if desired size of characters is larger than
     *                                  the ones available in the Array.
     */
    @Override
    protected ArrayList<Character> generateRandomNumbers(int size) throws IllegalArgumentException {
        if (size > VALID_NUMBERS.length) {
            throw new IllegalArgumentException("This password size is not supported yet :(. Sorry.");
        }
        HashMap<Character, Double> probabilityMap = generateProbabilities(VALID_NUMBERS);
        return chooseAndSortCharacters(size, probabilityMap);
    }

    /**
     * Used to generate an ArrayList of random special characters given the number
     * of random characters desired in the final password.
     * 
     * @param size the number of random special characters desired in the final
     *             password.
     * @return an ArrayList of random special characters.
     * @throws IllegalArgumentException if desired size of characters is larger than
     *                                  the ones available in the Array.
     */
    @Override
    protected ArrayList<Character> generateRandomSpecialCharacters(int size) throws IllegalArgumentException {
        if (size > VALID_SPECIAL_CHARACTERS.length) {
            throw new IllegalArgumentException("This password size is not supported yet :(. Sorry.");
        }
        HashMap<Character, Double> probabilityMap = generateProbabilities(VALID_SPECIAL_CHARACTERS);
        return chooseAndSortCharacters(size, probabilityMap);
    }

    /**
     * Used to generate the final password using a specified size for letters,
     * integers, and special characters.
     * 
     * @param numLetters   number of letters desired for the password.
     * @param numInts      number of integers desired for the password.
     * @param numSpecChars number of special characters desired for the password.
     * @throws IllegalArgumentException if desired size of characters is larger than
     *                                  the ones available in the Array.
     * @return the finalized password as a String.
     */
    @Override
    public String generatePassword(int numLetters, int numInts, int numSpecChars) throws IllegalArgumentException {
        ArrayList<Character> randomLetters = generateRandomLetters(numLetters);
        ArrayList<Character> randomNumbers = generateRandomNumbers(numInts);
        ArrayList<Character> randomSpecialCharacters = generateRandomSpecialCharacters(numSpecChars);
        return passwordBuilder(randomLetters, randomNumbers, randomSpecialCharacters);
    }

    public static void main(String[] args) {
        MyPasswordGenerator generator = new MyPasswordGenerator();
        long start = System.currentTimeMillis();
        String password = generator.generatePassword(0, 0, 32);
        long end = System.currentTimeMillis();
        System.out.format("Password:%s%n Time (ms): %d", password, end - start);
    }
}